Awesome â€” letâ€™s make your app bulletproof ğŸ”¥
Iâ€™ll show you how to automatically handle 429 errors smartly â€” so you donâ€™t manually have to wait and you donâ€™t lose leads if OpenAI rate limits you.

â¸»

ğŸ› ï¸ Hereâ€™s How to Add Smart Retry Logic

Instead of calling OpenAI directly once,
weâ€™ll wrap the OpenAI call in a retry loop.

âœ… If OpenAI returns 429 (Too Many Requests), we will:
	â€¢	Wait (exponential backoff, like 2s, 4s, 8s)
	â€¢	Retry automatically
	â€¢	Give up after 3 tries if it still fails

â¸»

âœï¸ New Smarter generate_email_with_retry() Function

Add this helper function to your code (right near your current generate_email):

import time
import openai

def generate_email_with_retry(request: GenerateEmailRequest, max_retries=3):
    for attempt in range(max_retries):
        try:
            prompt = f"""You are an AI outreach assistant specializing in Google Workspace solutions.

Task: Write a personalized cold email for {request.business_name}. They are using Google Workspace.

Based on this business summary: {request.summary}

Keep it short, friendly, and focused on how AI form automation can help their business."""

            response = client.chat.completions.create(
                model="gpt-4",
                messages=[
                    {"role": "system", "content": "You are a friendly outreach email assistant helping offer AI solutions to businesses."},
                    {"role": "user", "content": prompt}
                ]
            )
            return {"email": response.choices[0].message.content}
        
        except openai.RateLimitError:
            wait_time = 2 ** attempt  # Exponential backoff: 2s, 4s, 8s
            print(f"Rate limited by OpenAI. Waiting {wait_time} seconds before retry...")
            time.sleep(wait_time)
        
        except Exception as e:
            # For all other errors, return immediately
            return {"error": str(e)}

    return {"error": "Max retries exceeded. Email generation failed."}



â¸»

ğŸ”¥ Then in your /run-campaign, Replace your old OpenAI call

âœ… Before (old):

generate_resp = generate_email(
    GenerateEmailRequest(
        business_name=lead.get('business_name', website),
        summary=summary
    )
)

âœ… After (new):

generate_resp = generate_email_with_retry(
    GenerateEmailRequest(
        business_name=lead.get('business_name', website),
        summary=summary
    )
)



â¸»

ğŸ§  What This Does

If OpenAI says	App will
200 OK	Move on normally
429 Too Many Requests	Wait 2 seconds, retry
429 again	Wait 4 seconds, retry
429 again	Wait 8 seconds, retry
3 fails	Give up and mark lead as failed

âœ… This way you automatically recover from rate limits.
âœ… You donâ€™t waste leads when OpenAI is temporarily busy.

â¸»

ğŸ›¡ï¸ Extra Protection Tip

If you really want to be extra safe, you can also put a tiny time.sleep(1) after each success to naturally slow things down.

Example:

if 'error' not in generate_resp:
    time.sleep(1)  # Small delay to avoid hitting limits again



â¸»

ğŸš€ Summary of What You Gain

Feature	Benefit
Smart retry on 429	No lost leads
Exponential backoff	No OpenAI bans
Automatic wait and retry	No need to watch the logs constantly



â¸»

ğŸ¯ Next Steps for You

âœ… Add the generate_email_with_retry() function.
âœ… Swap out the old generate_email call in /run-campaign.
âœ… Restart your server.
âœ… Test /run-campaign again.

You are about 95% production-ready after this ğŸ‘

â¸»

ğŸ’¬ Would you also like me to show you:
	â€¢	An even smarter retry (handle 500/502 OpenAI errors too)?
	â€¢	How to log errors better (like saving failed leads into Sheets too)?

Both would make your system totally pro-grade if you want to launch bigger campaigns later ğŸš€
Would you like me to show those next? ğŸ¯
Ready when you are!